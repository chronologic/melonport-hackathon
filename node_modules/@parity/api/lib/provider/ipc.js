'use strict';var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self, call) {if (!self) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call && (typeof call === "object" || typeof call === "function") ? call : self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;} // Copyright 2015-2017 Parity Technologies (UK) Ltd.
// This file is part of Parity.

// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.

var EventEmitter = require('eventemitter3');

// https://github.com/electron/electron/issues/2288
var IS_ELECTRON = !!(typeof window !== 'undefined' && window && window.process && window.process.type);

var ipcRenderer = void 0;

if (IS_ELECTRON) {
  ipcRenderer = window.require('electron').ipcRenderer;
}

var METHOD_REQUEST_TOKEN = 'shell_requestNewToken';var

Ipc = function (_EventEmitter) {_inherits(Ipc, _EventEmitter);
  function Ipc(appId) {_classCallCheck(this, Ipc);var _this = _possibleConstructorReturn(this, (Ipc.__proto__ || Object.getPrototypeOf(Ipc)).call(this));

    _this._appId = appId;

    _this.id = 0;
    _this._messages = {};
    _this._queued = [];

    if (!IS_ELECTRON) {
      throw new Error('IpcProvider must be used in Electron environment.');
    }

    ipcRenderer.on('PARITY_SHELL_IPC_CHANNEL', _this.receiveMessage.bind(_this));return _this;
  }_createClass(Ipc, [{ key: '_constructMessage', value: function _constructMessage(

    id, data) {
      return Object.assign({}, data, {
        id: id,
        to: 'shell',
        from: this._appId,
        token: this._token });

    } }, { key: 'receiveMessage', value: function receiveMessage(

    _, _ref) {var id = _ref.id,error = _ref.error,from = _ref.from,to = _ref.to,token = _ref.token,result = _ref.result;
      var isTokenValid = token ? token === this._token : true;

      if (from !== 'shell' || to !== this._appId || !isTokenValid) {
        return;
      }

      if (this._messages[id].subscription) {
        this._messages[id].initial ?
        this._messages[id].resolve(result) :
        this._messages[id].callback(error && new Error(error), result);
        this._messages[id].initial = false;
      } else {
        this._messages[id].callback(error && new Error(error), result);
        this._messages[id] = null;
      }
    } }, { key: 'requestNewToken', value: function requestNewToken()

    {var _this2 = this;
      return new Promise(function (resolve, reject) {
        // Webview is ready when receivin the ping
        ipcRenderer.once('ping', function () {
          _this2.send(METHOD_REQUEST_TOKEN, [], function (error, token) {
            if (error) {
              reject(error);
            } else {
              _this2.setToken(token);
              resolve(token);
            }
          });
        });
      });
    } }, { key: '_send', value: function _send(

    message) {
      if (!this._token && message.data.method !== METHOD_REQUEST_TOKEN) {
        this._queued.push(message);

        return;
      }

      var id = ++this.id;
      var postMessage = this._constructMessage(id, message.data);

      this._messages[id] = Object.assign({}, postMessage, message.options);

      ipcRenderer.sendToHost('parity', { data: postMessage });
    } }, { key: 'send', value: function send(

    method, params, callback) {
      this._send({
        data: {
          method: method,
          params: params },

        options: {
          callback: callback } });


    } }, { key: '_sendQueued', value: function _sendQueued()

    {
      if (!this._token) {
        return;
      }

      this._queued.forEach(this._send.bind(this));
      this._queued = [];
    } }, { key: 'setToken', value: function setToken(

    token) {
      if (token) {
        this._connected = true;
        this._token = token;
        this.emit('connected');
        this._sendQueued();
      }
    } }, { key: 'subscribe', value: function subscribe(

    api, callback, params) {var _this3 = this;
      return new Promise(function (resolve, reject) {
        _this3._send({
          data: {
            api: api,
            params: params },

          options: {
            callback: callback,
            resolve: resolve,
            reject: reject,
            subscription: true,
            initial: true } });


      });
    }

    // FIXME: Should return callback, not promise
  }, { key: 'unsubscribe', value: function unsubscribe(subId) {var _this4 = this;
      return new Promise(function (resolve, reject) {
        _this4._send({
          data: {
            subId: subId },

          options: {
            callback: function callback(error, result) {
              error ? reject(error) : resolve(result);
            } } });


      });
    } }, { key: 'unsubscribeAll', value: function unsubscribeAll()

    {
      return this.unsubscribe('*');
    } }]);return Ipc;}(EventEmitter);


module.exports = Ipc;